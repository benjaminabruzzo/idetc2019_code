#!/usr/bin/env python

# Import required Python code.
import cv2
import roslib
import rospy
import yaml
import math
import message_filters
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import CameraInfo, Image
from std_msgs.msg import String
from geometry_msgs.msg import Twist
from nav_msgs.msg import Path

class logger():
	# Must have __init__(self) function for a class, similar to a C++ class constructor.
	def __init__(self):
		exp_date = rospy.get_param('~date')
		str_date = str(exp_date)

		exp_ugv = rospy.get_param('~ugv_n')
		str_ugv = str(exp_ugv)

		exp_trial = rospy.get_param('~trial')
		str_trial = str(exp_trial).zfill(3)
		
		# self.logger_filename = '/home/benjamin/ros/data/' + str_date + '/' + str_trial + '/kobuki_logger_' + str_trial + '.m'
		self.logger_filename = ('/home/benjamin/ros/data/{0}/{1}/{2}_logger_{1}.m').format(str_date,str_trial,str_ugv)
		print(self.logger_filename)
		self.file_logger = open(self.logger_filename, 'w')
		self.cmd_vel_index = 1;

		# Get the ~private namespace parameters from command line or launch file.
		cmd_vel_sub_topic = rospy.get_param('~cmd_vel_sub_topic')
		cmd_vel_pub_topic = rospy.get_param('~cmd_vel_pub_topic')
		self.cmd_vel_x_limit = rospy.get_param('~cmd_vel_x_limit')
		self.cmd_vel_w_limit = rospy.get_param('~cmd_vel_w_limit')

		# subscribers and publishers
		self.cmd_vel_sub = rospy.Subscriber(cmd_vel_sub_topic,Twist,self.cmd_vel_callback)
		self.cmd_vel_pub = rospy.Publisher(cmd_vel_pub_topic,Twist, queue_size=10)
		
		local_path_sub_topic = rospy.get_param('~local_path_topic')
		global_path_sub_topic = rospy.get_param('~global_path_topic')
		self.local_path_sub = rospy.Subscriber(local_path_sub_topic,Path,self.local_path_callback)
		self.global_path_sub = rospy.Subscriber(global_path_sub_topic,Path,self.global_path_callback)

		while not rospy.is_shutdown():
			rospy.spin()

		self.file_logger.close()
		
	def local_path_callback(self,data):
		# /move_base/DWAPlannerROS/local_plan
		# print data.poses
		self.file_logger.write("kobuki_logger.local_plan.time(" + str(data.header.seq+1) + ",1) = " + str(data.header.stamp.to_sec()) + ";\n")
		index = 1
		for poseStamped in data.poses:
			self.file_logger.write("kobuki_logger.local_plan.path.xyz{" + str(data.header.seq+1) +",1}(" + str(index) + ",:) = [" +\
				str(poseStamped.pose.position.x) + ", " + \
				str(poseStamped.pose.position.y) + ", " + \
				str(poseStamped.pose.position.z) + "];\n")
			self.file_logger.write("kobuki_logger.local_plan.path.q{" + str(data.header.seq+1) +",1}(" + str(index) + ",:) = [" +\
				str(poseStamped.pose.orientation.x) + ", " + \
				str(poseStamped.pose.orientation.y) + ", " + \
				str(poseStamped.pose.orientation.z) + ", " + \
				str(poseStamped.pose.orientation.w) + "];\n")
			qx = poseStamped.pose.orientation.x
			qy = poseStamped.pose.orientation.y
			qz = poseStamped.pose.orientation.z
			qw = poseStamped.pose.orientation.w
			yaw = math.atan2(2*(qx*qy-qz*qw),1-2*(qy*qy+qz*qz))
			# double yaw_end = atan2(2*(qx*qy-qz*qw),1-2*(qy*qy+qz*qz)); // radians
			self.file_logger.write("kobuki_logger.local_plan.path.yaw{" + str(data.header.seq+1) +",1}(" + str(index) + ",1) = " +\
				str(yaw) + ";\n")
			index += 1

	def global_path_callback(self,data):
		# log path generated by move base
		# print data.poses
		self.file_logger.write("kobuki_logger.global_plan.time(" + str(data.header.seq+1) + ",1) = " + str(data.header.stamp.to_sec()) + ";\n")
		index = 1
		for poseStamped in data.poses:
			self.file_logger.write("kobuki_logger.global_plan.path.xyz{" + str(data.header.seq+1) +",1}(" + str(index) + ",:) = [" +\
				str(poseStamped.pose.position.x) + ", " + \
				str(poseStamped.pose.position.y) + ", " + \
				str(poseStamped.pose.position.z) + "];\n")
			self.file_logger.write("kobuki_logger.global_plan.path.q{" + str(data.header.seq+1) +",1}(" + str(index) + ",:) = [" +\
				str(poseStamped.pose.orientation.x) + ", " + \
				str(poseStamped.pose.orientation.y) + ", " + \
				str(poseStamped.pose.orientation.z) + ", " + \
				str(poseStamped.pose.orientation.w) + "];\n")
			index += 1

	def cmd_vel_publish(self):
		self.cmd_vel_pub.publish(self.cmd_vel_pub_msg)

	def cmd_vel_callback(self,data):
		# seconds = rospy.get_time()
		# msg_time = rospy.Time.now()
		msg_time = rospy.get_time()
		self.cmd_vel_pub_msg = Twist()
		if abs(data.linear.x) >= self.cmd_vel_x_limit:
			if data.linear.x >= 0.0:
				self.cmd_vel_pub_msg.linear.x = self.cmd_vel_x_limit
			else:
				self.cmd_vel_pub_msg.linear.x = -self.cmd_vel_x_limit
		else:
				self.cmd_vel_pub_msg.linear.x = data.linear.x
		if abs(data.angular.z) >= self.cmd_vel_w_limit:
			if data.angular.z >= 0.0:
				self.cmd_vel_pub_msg.angular.z = self.cmd_vel_w_limit
			else:
				self.cmd_vel_pub_msg.angular.z = -self.cmd_vel_w_limit
		else:
				self.cmd_vel_pub_msg.angular.z = data.angular.z
		# print "cmd_vel.linear.x : " + str(data.linear.x)
		# print "cmd_vel.angular.z : " + str(data.angular.z)
		# print "self.cmd_vel_pub_msg.linear.x : " + str(self.cmd_vel_pub_msg.linear.x)
		# print "self.cmd_vel_pub_msg.angular.z : " + str(self.cmd_vel_pub_msg.angular.z)
		# fprintf (mFile, "uavRecorder.ckfinit.Rk(1,:) = [%6.14f, %6.14f, %6.14f, %6.14f];\n",ckf.Rk.at<double>(0, 0),ckf.Rk.at<double>(0, 1),ckf.Rk.at<double>(0, 2),ckf.Rk.at<double>(0, 3));
		self.cmd_vel_publish()
		self.file_logger.write("kobuki_logger.cmd_vel.time(" +str(self.cmd_vel_index) + ",1) = " + str(msg_time) + ";\n")
		self.file_logger.write("kobuki_logger.cmd_vel_raw.linear_x(" + str(self.cmd_vel_index) + ",1) = " + str(data.linear.x) + ";\n")
		self.file_logger.write("kobuki_logger.cmd_vel_raw.angular_z(" + str(self.cmd_vel_index) + ",1) = " + str(data.angular.z) + ";\n")
		self.file_logger.write("kobuki_logger.cmd_vel_limited.linear_x(" + str(self.cmd_vel_index) + ",1) = " + str(self.cmd_vel_pub_msg.linear.x) + ";\n")
		self.file_logger.write("kobuki_logger.cmd_vel_limited.angular_z(" + str(self.cmd_vel_index) + ",1) = " + str(self.cmd_vel_pub_msg.angular.z) + ";\n")
		self.cmd_vel_index += 1

	def nxm2mfile(fileservice, data, datastring): # write data to file
		# nxm2mfile(f,LeftObjP, "caldata.left.chessboard3Dpoints")
		for i in range(0,data.shape[0]):
			line = datastring + "(" + str(i+1) + ",:)=["
			for j in range(0,data.shape[1]):
				line += (str(data[i,j])) + " "
			line += "];\n"
			fileservice.write(line)
		fileservice.write("\n")

if __name__ == '__main__':
    # Initialize the node and name it.
    rospy.init_node('kobuki_logger')
    # Go to class functions that do all the heavy lifting. Do error checking.
    try:
        log = logger()
    except rospy.ROSInterruptException: pass
